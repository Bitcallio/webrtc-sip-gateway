#!KAMAILIO

#!substdef "!SIP_PROVIDER_URI!sip:127.0.0.1:5060;transport=udp!g"
#!substdef "!GATEWAY_DOMAIN!localhost!g"
#!substdef "!SIP_PORT!5060!g"
#!substdef "!SIP_UPSTREAM_TRANSPORT!udp!g"
#!substdef "!WEBPHONE_ORIGIN_PATTERN!.*!g"
#!substdef "!WEBPHONE_ORIGIN!*!g"
#!substdef "!INTERNAL_WSS_PORT!8443!g"

#!trydefenv WITH_REVERSE_PROXY
#!trydefenv WITH_SIP_TLS

debug=2
log_stderror=yes
fork=no
children=8
auto_aliases=no
alias="GATEWAY_DOMAIN"

enable_tls=yes

#!ifdef WITH_REVERSE_PROXY
listen=tls:127.0.0.1:INTERNAL_WSS_PORT advertise GATEWAY_DOMAIN:443
#!else
listen=tls:0.0.0.0:443
#!endif
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060
#!ifdef WITH_SIP_TLS
listen=tls:0.0.0.0:5061
#!endif

tcp_accept_no_cl=yes
tcp_connection_lifetime=3604
tcp_rd_buf_size=16384

loadmodule "tm.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "pv.so"
loadmodule "xlog.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xhttp.so"
loadmodule "websocket.so"
loadmodule "tls.so"
loadmodule "http_client.so"
loadmodule "nathelper.so"
loadmodule "path.so"
loadmodule "outbound.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "rtpengine.so"
loadmodule "dialog.so"

modparam("tls", "config", "/etc/kamailio/tls.cfg")

modparam("rr", "enable_double_rr", 2)

modparam("usrloc", "db_mode", 0)

modparam("registrar", "use_path", 0)
modparam("registrar", "lookup_filter_mode", 2)

modparam("nathelper", "received_avp", "$avp(RECEIVED)")
modparam("registrar", "received_avp", "$avp(RECEIVED)")

modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:2223")

modparam("dialog", "db_mode", 0)
modparam("dialog", "hash_size", 4096)
modparam("dialog", "default_timeout", 43200)

modparam("http_client", "query_result", 0)
modparam("http_client", "query_maxdatasize", 4096)
modparam("http_client", "connection_timeout", 2)

modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "cors_mode", 2)

request_route {
    route(REQINIT);

    if (nat_uac_test("64")) {
        force_rport();
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if (!add_contact_alias()) {
                xlog("L_ERR", "Failed add_contact_alias for <$ct>\\n");
                sl_send_reply("400", "Bad Request");
                exit;
            }
        }
    }

    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            t_relay();
        }
        exit;
    }

    if (is_method("OPTIONS") && uri == myself) {
        sl_send_reply("200", "OK");
        exit;
    }

    t_check_trans();

    if (is_method("REGISTER")) {
        route(REGISTRAR);
        exit;
    }

    if (is_method("INVITE")) {
        route(INVITE);
        exit;
    }

    route(RELAY);
}

route[REGISTRAR] {
    $avp(orig_contact) = $ct;

    if (!save("location", "0x02")) {
        sl_reply_error();
        exit;
    }

    remove_hf("Contact");
    append_hf("Contact: <sip:$fU@GATEWAY_DOMAIN:SIP_PORT;transport=SIP_UPSTREAM_TRANSPORT>\\r\\n");

    add_path_received();
    append_hf("Supported: path\\r\\n");

    $du = "SIP_PROVIDER_URI";

    t_on_reply("REGISTER_REPLY");
    t_on_failure("REGISTER_FAIL");

    route(RELAY);
}

onreply_route[REGISTER_REPLY] {
    if (nat_uac_test("64")) {
        add_contact_alias();
    }

    if ($rs == "200" && $avp(orig_contact) != $null) {
        remove_hf("Contact");
        append_hf("Contact: $avp(orig_contact)\\r\\n");
    }
}

failure_route[REGISTER_FAIL] {
    if (t_is_canceled()) {
        exit;
    }

    if (t_check_status("403|404|488|5[0-9][0-9]")) {
        xlog("L_WARN", "REGISTER hard failure, unregistering <$tu>\\n");
        unregister("location", "$tu");
    }
}

route[INVITE] {
    record_route();

    if (!has_totag()) {
        dlg_manage();
    }

    if ($proto =~ "ws") {
        $du = "SIP_PROVIDER_URI";
    } else {
        if (!lookup("location")) {
            sl_send_reply("404", "Not Found");
            exit;
        }
    }

    if (has_body("application/sdp")) {
        route(NATMANAGE);
    }

    t_on_reply("INVITE_REPLY");
    route(RELAY);
}

onreply_route[INVITE_REPLY] {
    if (nat_uac_test("64")) {
        add_contact_alias();
    }

    if (t_check_status("(180)|(183)|(200)") && has_body("application/sdp")) {
        route(NATMANAGE);
    }
}

route[WITHINDLG] {
    if (loose_route()) {
        if ($du == "") {
            if (!handle_ruri_alias()) {
                xlog("L_ERR", "Bad alias in R-URI <$ru>\\n");
                sl_send_reply("400", "Bad Request");
                exit;
            }
        }

        if (is_method("INVITE|UPDATE")) {
            if (has_body("application/sdp")) {
                route(NATMANAGE);
            }
            t_on_reply("INVITE_REPLY");
        }

        route(RELAY);
    } else {
        if (is_method("ACK")) {
            if (t_check_trans()) {
                route(RELAY);
                exit;
            }
            exit;
        }
        sl_send_reply("404", "Not Found");
    }

    exit;
}

route[NATMANAGE] {
    if (!has_body("application/sdp")) {
        return;
    }

    if ($proto =~ "ws") {
        $var(rtpflags) = "replace-origin replace-session-connection ICE=remove rtcp-mux-demux DTLS=off SDES-off RTP/AVP";
    } else {
        $var(rtpflags) = "replace-origin replace-session-connection ICE=force DTLS=passive SDES-off rtcp-mux-offer RTP/SAVPF";
    }

    rtpengine_manage("$var(rtpflags)");
}

route[RELAY] {
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

route[REQINIT] {
    $var(allowed_domains) = $env(ALLOWED_SIP_DOMAINS);

    if (!mf_process_maxfwd_header("16")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    if (!has_totag() && $proto =~ "ws" && $var(allowed_domains) != "") {
        if (!($var(allowed_domains) =~ "(^|,)$rd(,|$)")) {
            xlog("L_WARN", "Blocked request for non-allowlisted domain <$rd>\\n");
            sl_send_reply("403", "Domain Not Allowed");
            exit;
        }
    }
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if ($hdr(Upgrade) =~ "websocket"
            && $hdr(Connection) =~ "Upgrade"
            && $rm == "GET") {
        if (ws_handle_handshake()) {
            exit;
        }
        xhttp_reply("500", "Server Error", "text/plain", "WebSocket handshake failed");
        exit;
    }

    if ($hu =~ "^/turn-credentials") {
        $var(turn_api_token) = $env(TURN_API_TOKEN);

        if ($rm == "OPTIONS") {
            append_to_reply("Access-Control-Allow-Origin: WEBPHONE_ORIGIN\\r\\n");
            append_to_reply("Access-Control-Allow-Methods: GET, OPTIONS\\r\\n");
            append_to_reply("Access-Control-Allow-Headers: Authorization\\r\\n");
            append_to_reply("Access-Control-Max-Age: 86400\\r\\n");
            append_to_reply("Vary: Origin\\r\\n");
            xhttp_reply("200", "OK", "text/plain", "ok");
            exit;
        }

        if ($hdr(Origin) != $null) {
            if (!($hdr(Origin) =~ "WEBPHONE_ORIGIN_PATTERN")) {
                xhttp_reply("403", "Forbidden", "text/plain", "Origin not allowed");
                exit;
            }
        }

        if ($var(turn_api_token) != "") {
            $var(auth_expected) = "Bearer " + $var(turn_api_token);
            if ($hdr(Authorization) != $var(auth_expected)) {
                xhttp_reply("401", "Unauthorized", "text/plain", "Missing or invalid token");
                exit;
            }
        }

        if (!http_client_query("http://127.0.0.1:8880/turn-credentials", "$var(turn_json)")) {
            xhttp_reply("502", "Bad Gateway", "text/plain", "TURN credential helper unavailable");
            exit;
        }

        append_to_reply("Access-Control-Allow-Origin: WEBPHONE_ORIGIN\\r\\n");
        append_to_reply("Vary: Origin\\r\\n");
        xhttp_reply("200", "OK", "application/json", "$var(turn_json)");
        exit;
    }

    xhttp_reply("404", "Not Found", "text/plain", "not found");
}

event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket closed from $si:$sp\\n");
}
